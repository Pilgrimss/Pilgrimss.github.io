<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blueflamingo.tech","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="This article discusses what kind of memory management we need and several important design features to obtain it, such as address space, virtual memory and page replacement.">
<meta property="og:type" content="article">
<meta property="og:title" content="Memory Management">
<meta property="og:url" content="https://blueflamingo.tech/2020/08/03/Memory-Management/index.html">
<meta property="og:site_name" content="Blue Flamingo">
<meta property="og:description" content="This article discusses what kind of memory management we need and several important design features to obtain it, such as address space, virtual memory and page replacement.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/phi.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/two.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/swap.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/grow.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/mana.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/termi.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/mmu.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/map.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/pte.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/tlb.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/mlt.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/share.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/chance.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/clock.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/aging.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/work.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/worka.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/wsc.png">
<meta property="og:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/pff.png">
<meta property="article:published_time" content="2020-08-03T19:07:47.000Z">
<meta property="article:modified_time" content="2020-12-11T01:59:16.894Z">
<meta property="article:author" content="Katherine">
<meta property="article:tag" content="Operating Systems">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blueflamingo.tech/2020/08/03/Memory-Management/Memory-Management/phi.png">

<link rel="canonical" href="https://blueflamingo.tech/2020/08/03/Memory-Management/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Memory Management | Blue Flamingo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blue Flamingo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Pilgrimss" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueflamingo.tech/2020/08/03/Memory-Management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Katherine">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue Flamingo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Memory Management
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-03 15:07:47" itemprop="dateCreated datePublished" datetime="2020-08-03T15:07:47-04:00">2020-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-10 20:59:16" itemprop="dateModified" datetime="2020-12-10T20:59:16-05:00">2020-12-10</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/08/03/Memory-Management/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/08/03/Memory-Management/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">This article discusses what kind of memory management we need and several important design features to obtain it, such as address space, virtual memory and page replacement.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>What every programmer would like is a private, infinitely large, infinitely fast memory is also nonvolatile. Unfortunately, such memories don’t exist at present. A second choice is <strong>memory hierarchy</strong>, with cache, main memory and disk storage. </p>
<p>The job of operating system is to abstract this hierachy into a userful model and then manage the abstraction. And this part of the OS is called the **memory manager **. </p>
<h1 id="Memory-Management-Requirements"><a href="#Memory-Management-Requirements" class="headerlink" title="Memory Management Requirements"></a>Memory Management Requirements</h1><p>There are some requirements that memory management is intened to satisfy:</p>
<ul>
<li>Relocation:</li>
<li>Protection:</li>
<li>Sharing</li>
<li>Logical organization</li>
<li>Physical organization</li>
</ul>
<h1 id="No-Memory-Abstraction"><a href="#No-Memory-Abstraction" class="headerlink" title="No Memory Abstraction"></a>No Memory Abstraction</h1><p>With the model of memory being just physical memory, generally only one process at a time can be running.</p>
<img src="Memory-Management/phi.png" style="zoom:40%;" />

<p>One way to get some parallelism in such a system with no memory abstracion is to program with multiple threads, since all threads in a process are supposed to see the same memory image.</p>
<p>It is also possible to run multiple programs at the same time by <strong>swapping</strong>, the OS:</p>
<ul>
<li>first saves the entire contents of memoey to a disk file</li>
<li>then brings in and runs the next program</li>
</ul>
<p>Suppose two programs loaded consecutively into memory, it raises a problem that the two programs both reference absoulte physical memory. </p>
<img src="Memory-Management/two.png" style="zoom:40%;" />

<p>One solution is called <strong>static relocation</strong>. When a program was loaded, the constant of starting address is added to every program address. However, it’s quite slow, and requires some way to tell what is an address and what is a constant.</p>
<h1 id="Memory-Abstraction-Address-space"><a href="#Memory-Abstraction-Address-space" class="headerlink" title="Memory Abstraction: Address space"></a>Memory Abstraction: Address space</h1><p>An <strong>address space</strong> is the set of addresses that a procss can use to address memory. Each process has its own address space, independent of those belonging to other processes.</p>
<h2 id="Base-and-Limit-registers"><a href="#Base-and-Limit-registers" class="headerlink" title="Base and Limit registers"></a>Base and Limit registers</h2><p>There is a simple solution to give each program its own address space, with the <strong>dynamic relocation</strong> technique. It maps each process’s address space onto a different part of physical memory with two special hardware registers:</p>
<ul>
<li><strong>Base</strong>:  the physical address where its program begins in memory</li>
<li><strong>Limit</strong>: the length of the program</li>
</ul>
<p>Every time a process referent memory:</p>
<ul>
<li>CPU automatically adds the base value to the address generated by the process before sending it out on to memory bus</li>
<li>It also checks whether the address offered is equal to or greater than the value in limit register.</li>
</ul>
<p>The base and limit registers are protected so that only the operating system can modify them.</p>
<p>A <strong>disadvantage</strong> is the need to perform an addition and a comparsion on every memory reference.</p>
<h2 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h2><p>In practice, the total amount of RAM needed by all the processes is oftern much more than can fit in memory. The simplest strategy to dealing with memory overload, called <strong>swapping</strong>, consists of bringing in each process in its entirety, running it for a while, then putting it back on the disk.</p>
<img src="Memory-Management/swap.png" style="zoom:40%;" />

<p>When swapping creates multiple holes in memory, it is possible to combine them all into a big one by moving all the processes downward as far as possible, which is called <strong>memory compaction</strong>.</p>
<p>If a process tries a grow:</p>
<ul>
<li>if a hole is adjacent to the process, it can be allocated</li>
<li>if not, it has to be moved to a bigger hole, or one or more processes have to be swapped out to create a larger enough hole</li>
<li>if it cannot grow in memory and the swap area on the disk is full, the process has to be suspended until there is enough memory</li>
</ul>
<p>Since most processes tend to grow, it is a good idea to <strong>allocate</strong> a little <strong>extra memory</strong>.</p>
<img src="Memory-Management/grow.png" style="zoom:40%;" />

<h2 id="Managing-Free-Memory"><a href="#Managing-Free-Memory" class="headerlink" title="Managing Free Memory"></a>Managing Free Memory</h2><p>When memory is assigned dynamic, the operating system must manage it. There are two ways to keep track of  memory usage: bitmaps and free lists.</p>
<img src="Memory-Management/mana.png" style="zoom:40%;" />

<h3 id="Memory-Management-with-Bitmaps"><a href="#Memory-Management-with-Bitmaps" class="headerlink" title="Memory Management with Bitmaps"></a>Memory Management with Bitmaps</h3><p>With a bitmap, memory is divied into allocation units. Corresponding to each allocation unit is a bit in the bitmap, which is 0 if the unit is free and 1 if it is occupied.</p>
<p>The main <strong>problem</strong> is that when it needs to bring a $k$-unit process into memory, the memory manager must search the bitmap to find $k$ consecutive 0 bits in the map, which is quite slow.</p>
<h3 id="Memory-Management-with-Linked-Lists"><a href="#Memory-Management-with-Linked-Lists" class="headerlink" title="Memory Management with Linked Lists"></a>Memory Management with Linked Lists</h3><p>Another way is to maintain a linked list of allocated and free memory segements, where a segment either contains a process or is a hole.</p>
<p>It is more convenient to have the list as a double-linked list, which makes it easier to find the previous entry and see if a merge is possible.</p>
<img src="Memory-Management/termi.png" style="zoom:40%;" />

<h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h1><p>The problem of programs larger than memory has been around since the beginning of computing, one method is known as <strong>virtual memory</strong>. The basic idea is that:</p>
<ul>
<li>Each program has its own address space, which is broken into chunks called <strong>pages</strong></li>
<li>Each page is a contiguous range of addresses</li>
<li>Pages are mapped onto physical memory, but not all pages have to be in physical memory at the same time to run the program</li>
</ul>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>Most virtual memory system use a technique called paging. </p>
<ul>
<li><p>The program-generated addresses are called <strong>virtual addresses</strong> and form the <strong>virtual address space</strong>.</p>
</li>
<li><p><strong>MMU (Memory Management Unit)</strong> maps the virtual addresses onto the physical addresses.</p>
</li>
</ul>
<img src="Memory-Management/mmu.png" style="zoom:40%;" />

<p>A simple mapping example is as follows. </p>
<ul>
<li>The virtual adddress space consists of fixed-size units called pages.</li>
<li>The corresponding units in the physical memory are called <strong>frames</strong>.</li>
<li>The pages and frames are generally the same size.</li>
</ul>
<img src="Memory-Management/map.png" style="zoom:40%;" />

<h2 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h2><h3 id="Structure-of-a-page-table-entry"><a href="#Structure-of-a-page-table-entry" class="headerlink" title="Structure of a page table entry"></a>Structure of a page table entry</h3><p>Let us go to the detials of a single page table entry.</p>
<ul>
<li><p><strong>Page frame number</strong></p>
</li>
<li><p><strong>Present/absent</strong>: 1 if the entry is valid cand can be used</p>
</li>
<li><p><strong>Protection</strong>: ‘kernel’ + ‘w’</p>
<ul>
<li>if the kernel bit is set, only the kernel can translate this page</li>
<li>if the writeprotected bit is set the page can only be read</li>
</ul>
</li>
<li><p><strong>Reference</strong>: set whenever a page is referenced, either for reading or for writing</p>
</li>
<li><p><strong>Modified</strong>: set when a page is writtern to</p>
</li>
<li><p><strong>Caching disabled</strong> </p>
</li>
</ul>
<img src="Memory-Management/pte.png" style="zoom:40%;" />

<h2 id="Speeding-up-Paging"><a href="#Speeding-up-Paging" class="headerlink" title="Speeding up Paging"></a>Speeding up Paging</h2><p>In any paging system, two major issues must be faced:</p>
<ul>
<li>The mapping from virtual address to physical address must be fast</li>
<li>If the virtual address space is large, the page table will be large</li>
</ul>
<h3 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB (Translation Lookaside Buffer)"></a>TLB (Translation Lookaside Buffer)</h3><p>The solution for the first issue is to equip computers with a small hardware device for mapping virtual addresses to physical addresses without going through the page table. The device is called <strong>TLB</strong>, which is usually inside the MMU.</p>
<img src="Memory-Management/tlb.png" style="zoom:40%;" />

<h3 id="Multi-level-Page-Table"><a href="#Multi-level-Page-Table" class="headerlink" title="Multi-level Page Table"></a>Multi-level Page Table</h3><img src="Memory-Management/mlt.png" style="zoom:40%;" />

<h3 id="Shared-Pages"><a href="#Shared-Pages" class="headerlink" title="Shared Pages"></a>Shared Pages</h3><img src="Memory-Management/share.png" style="zoom:40%;" />

<p>In UNIX, after the <strong>fork</strong> syscall, the parent and child are required to share both program text and data. It’s implemented as to give each process its own page table and have both of them point to the same set of page. However, all the data pages mapped into both processes as <strong>Read Only</strong>. </p>
<p>As soon as either a process updates a memory word, a <strong>copy</strong> is then made of the offending page so that each process now has its own private copy, both are now set <strong>Read/ Write</strong>.</p>
<p>Thie approach is call <strong>copy on write</strong>.</p>
<h1 id="Page-Replacement-algorithms"><a href="#Page-Replacement-algorithms" class="headerlink" title="Page Replacement algorithms"></a>Page Replacement algorithms</h1><h2 id="Optimal-Page-Replacement-Algorithm"><a href="#Optimal-Page-Replacement-Algorithm" class="headerlink" title="Optimal Page Replacement Algorithm"></a>Optimal Page Replacement Algorithm</h2><ul>
<li><p>Each page is labeled with the number of instructions that will be executed before the page is first referenced.</p>
</li>
<li><p>The page with the highest label should be removed</p>
</li>
</ul>
<h2 id="The-FIFO-Page-Replacement-Algorithm"><a href="#The-FIFO-Page-Replacement-Algorithm" class="headerlink" title="The FIFO Page Replacement Algorithm"></a>The FIFO Page Replacement Algorithm</h2><ul>
<li>The operating system maintains a list of all pages currently in memory, with the most recent arrival at the tail and the least recent arrival at the head.</li>
<li>On a page fault, the apge at the head is removed and the new page added to the tail of the list</li>
</ul>
<h2 id="The-Second-Chance-Page-Replacement-Algorithm"><a href="#The-Second-Chance-Page-Replacement-Algorithm" class="headerlink" title="The Second-Chance Page Replacement Algorithm"></a>The Second-Chance Page Replacement Algorithm</h2><p>A simple modification of FIFO that inspects the R bit of the oldest page:</p>
<ul>
<li><p>If it is 0, the page is replaced immediately.</p>
</li>
<li><p>If the R bit is 1, </p>
<ul>
<li>the bit is cleared, </li>
<li>the page is put onto the end of the list of the pages</li>
<li>the search continues</li>
</ul>
</li>
</ul>
<img src="Memory-Management/chance.png" style="zoom:40%;" />

<h2 id="The-Clock-Page-Replacement-Policy"><a href="#The-Clock-Page-Replacement-Policy" class="headerlink" title="The Clock Page Replacement Policy"></a>The Clock Page Replacement Policy</h2><ul>
<li>Keep all the page frames on a circular list in the form of a clock</li>
<li>The hand points to the oldest page</li>
</ul>
<img src="Memory-Management/clock.png" style="zoom:40%;" />

<h2 id="The-Not-Recently-Used-NRU-Replacement-Algorithm"><a href="#The-Not-Recently-Used-NRU-Replacement-Algorithm" class="headerlink" title="The Not Recently Used (NRU) Replacement Algorithm"></a>The Not Recently Used (NRU) Replacement Algorithm</h2><ul>
<li><p>Preidocially, the R bit is cleared</p>
</li>
<li><p>When a page fault occurs, the opearting system inspects all the pages and divides them into four categories based on current values of their R and M bits</p>
<ul>
<li>Class 0: not referenced, not modified. </li>
<li>Class 1: not referenced, modified.</li>
<li> Class 2: referenced, not modified. </li>
<li>Class 3: referenced, modified.</li>
</ul>
</li>
<li><p>The NRU (Not Recently Used) algorithm removes a page at random from the lowest-numbered nonempty class.</p>
</li>
</ul>
<h2 id="The-Least-Recently-Used-LRU-Page-Replacement-Algorithm"><a href="#The-Least-Recently-Used-LRU-Page-Replacement-Algorithm" class="headerlink" title="The Least Recently Used (LRU) Page Replacement Algorithm"></a>The Least Recently Used (LRU) Page Replacement Algorithm</h2><p>When a page fault occurs, throw out the page that has been unused for the longest time.</p>
<h3 id="Hardware-Implementation"><a href="#Hardware-Implementation" class="headerlink" title="Hardware Implementation"></a>Hardware Implementation</h3><ul>
<li><p>Equipping the hardware with a 64-bit counter, C, that is automatically incremented after each instruction.</p>
</li>
<li><p>Each page table entry must also have a field large enough to contain the counter.</p>
</li>
<li><p>After each memory reference, the current value of C is stored in the page table entry for the page just referenced.</p>
</li>
<li><p>When a page fault occurs, the operating system examines all the counters in the page table to find the lowest one.</p>
</li>
</ul>
<h3 id="Software-Implementation"><a href="#Software-Implementation" class="headerlink" title="Software Implementation"></a>Software Implementation</h3><h4 id="NFU-Not-Frequently-Used-Algorithm"><a href="#NFU-Not-Frequently-Used-Algorithm" class="headerlink" title="NFU (Not Frequently Used) Algorithm"></a>NFU (Not Frequently Used) Algorithm</h4><ul>
<li><p>It requires a software counter associated with each page, initially zero.</p>
</li>
<li><p>At each clock interrupt, the operating system scans all the pages in memory. </p>
<ul>
<li>For each page, the R bit, which is 0 or 1, is added to the counter.</li>
</ul>
</li>
<li><p>When a page fault occurs, the page with the lowest counter is chosen for replacement.</p>
</li>
</ul>
<h4 id="Aging-Algorithm"><a href="#Aging-Algorithm" class="headerlink" title="Aging Algorithm"></a>Aging Algorithm</h4><p>It modifies NFU in two parts:</p>
<ul>
<li>the counters are each shifted right 1 bit before the R bit is added in.</li>
<li>the R bit is added to the leftmost rather than the rightmost bit.</li>
</ul>
<img src="Memory-Management/aging.png" style="zoom:40%;" />

<h2 id="The-Working-Set-Page-Replacement-Algorithm"><a href="#The-Working-Set-Page-Replacement-Algorithm" class="headerlink" title="The Working Set Page Replacement Algorithm"></a>The Working Set Page Replacement Algorithm</h2><p>The set of pages that a process is currently using is its <strong>working set</strong>. A program causing page faults every few instructions is said to be <strong>thrashing</strong>.</p>
<p>In a multiprogramming system, processes are often moved to disk. The question arises of what to do when a process is brought back in again. </p>
<p>Many paging systems try to keep track of each process’ working set and make sure that it is in memory before letting the process run. This approach is called the <strong>working set model</strong>.  Loading the pages before letting processes run is also called <strong>prepaging</strong>.</p>
<img src="Memory-Management/work.png" style="zoom:40%;" />

<p>The algorithm works as follows:</p>
<ul>
<li>Clear the reference bit periodically </li>
<li>On every page fault, scan the page table and examine the R bit<ul>
<li>if it is 1, the current virtual time is written into the Time of last use field in the page table</li>
<li>if R is 0, ts age (the current virtual time minus its Time of last use) is computed and compared to $\tau$. If the age is greater than τ , the page is no longer in the working set and the new page replaces it.</li>
<li>The scan continues updating the remaining entries.</li>
</ul>
</li>
</ul>
<img src="Memory-Management/worka.png" style="zoom:40%;" />

<h2 id="The-WSClock-Page-Replacement-Algorithm"><a href="#The-WSClock-Page-Replacement-Algorithm" class="headerlink" title="The WSClock Page Replacement Algorithm"></a>The WSClock Page Replacement Algorithm</h2><ul>
<li>The data structure needed is a circular list of page frames, as in the clock algorithm</li>
<li>Each entry contains the Time of last use field from the basic working set algorithm, as well as the R bit (shown) and the M bit (not shown).</li>
<li>At each page fault the page pointed to by the hand is examined first.<ul>
<li>If the R bit is set to 1, the R bit is then set to 0, the hand advanced to the next page</li>
<li>if the page pointed to has R = 0, <ul>
<li>If the age is greater than τ and the page is clean, the page frame is simply claimed and the new page put there</li>
<li>if the page is dirty, the write to disk is scheduled, but the hand is advanced and the algorithm continues with the next page.</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="Memory-Management/wsc.png" style="zoom:40%;" />

<h1 id="DESIGN-ISSUES-FOR-PAGING-SYSTEMS"><a href="#DESIGN-ISSUES-FOR-PAGING-SYSTEMS" class="headerlink" title="DESIGN ISSUES FOR PAGING SYSTEMS"></a>DESIGN ISSUES FOR PAGING SYSTEMS</h1><h2 id="Local-versus-Global-Allocation-Policies"><a href="#Local-versus-Global-Allocation-Policies" class="headerlink" title="Local versus Global Allocation Policies"></a>Local versus Global Allocation Policies</h2><p>If a global algorithm is used, the system must continually decide how many page frames to assign to each process.</p>
<ul>
<li>One way is to periodically determine the number of running processes and allocate each process an <strong>equal</strong> share.</li>
<li>The other way is to start each process up with some number of pages <strong>proportional</strong> to the process’ size, but the allocation has to be updated dynamically as the processes run.<ul>
<li>One way to manage the allocation is to use the <strong>PFF (Page Fault Frequency</strong>) algorithm, It tells when to increase or decrease a process’ page allocation.</li>
</ul>
</li>
</ul>
<img src="Memory-Management/pff.png" style="zoom:40%;" />

<p>The dashed line marked A corresponds to a page fault rate that is unacceptably high, so the faulting process is given more page frames to reduce the fault rate. The dashed line marked B corresponds to a page fault rate so low that we can assume the process has too much memory. In this case, page frames may be taken away from it. Thus, PFF tries to keep the paging rate for each process within acceptable bounds.</p>
<h2 id="Page-Size"><a href="#Page-Size" class="headerlink" title="Page Size"></a>Page Size</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Implementation-Issues"><a href="#Implementation-Issues" class="headerlink" title="Implementation Issues"></a>Implementation Issues</h1>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Operating-Systems/" rel="tag"># Operating Systems</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/03/Concurrency/" rel="prev" title="Concurrency">
      <i class="fa fa-chevron-left"></i> Concurrency
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/02/String-to-Integer/" rel="next" title="String to Integer">
      String to Integer <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Memory-Management-Requirements"><span class="nav-number">1.</span> <span class="nav-text">Memory Management Requirements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#No-Memory-Abstraction"><span class="nav-number">2.</span> <span class="nav-text">No Memory Abstraction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Memory-Abstraction-Address-space"><span class="nav-number">3.</span> <span class="nav-text">Memory Abstraction: Address space</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Base-and-Limit-registers"><span class="nav-number">3.1.</span> <span class="nav-text">Base and Limit registers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swapping"><span class="nav-number">3.2.</span> <span class="nav-text">Swapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Managing-Free-Memory"><span class="nav-number">3.3.</span> <span class="nav-text">Managing Free Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Management-with-Bitmaps"><span class="nav-number">3.3.1.</span> <span class="nav-text">Memory Management with Bitmaps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Management-with-Linked-Lists"><span class="nav-number">3.3.2.</span> <span class="nav-text">Memory Management with Linked Lists</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Virtual-Memory"><span class="nav-number">4.</span> <span class="nav-text">Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Paging"><span class="nav-number">4.1.</span> <span class="nav-text">Paging</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-tables"><span class="nav-number">4.2.</span> <span class="nav-text">Page tables</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Structure-of-a-page-table-entry"><span class="nav-number">4.2.1.</span> <span class="nav-text">Structure of a page table entry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Speeding-up-Paging"><span class="nav-number">4.3.</span> <span class="nav-text">Speeding up Paging</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB-Translation-Lookaside-Buffer"><span class="nav-number">4.3.1.</span> <span class="nav-text">TLB (Translation Lookaside Buffer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-level-Page-Table"><span class="nav-number">4.3.2.</span> <span class="nav-text">Multi-level Page Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shared-Pages"><span class="nav-number">4.3.3.</span> <span class="nav-text">Shared Pages</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Page-Replacement-algorithms"><span class="nav-number">5.</span> <span class="nav-text">Page Replacement algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Optimal-Page-Replacement-Algorithm"><span class="nav-number">5.1.</span> <span class="nav-text">Optimal Page Replacement Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-FIFO-Page-Replacement-Algorithm"><span class="nav-number">5.2.</span> <span class="nav-text">The FIFO Page Replacement Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Second-Chance-Page-Replacement-Algorithm"><span class="nav-number">5.3.</span> <span class="nav-text">The Second-Chance Page Replacement Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Clock-Page-Replacement-Policy"><span class="nav-number">5.4.</span> <span class="nav-text">The Clock Page Replacement Policy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Not-Recently-Used-NRU-Replacement-Algorithm"><span class="nav-number">5.5.</span> <span class="nav-text">The Not Recently Used (NRU) Replacement Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Least-Recently-Used-LRU-Page-Replacement-Algorithm"><span class="nav-number">5.6.</span> <span class="nav-text">The Least Recently Used (LRU) Page Replacement Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hardware-Implementation"><span class="nav-number">5.6.1.</span> <span class="nav-text">Hardware Implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Software-Implementation"><span class="nav-number">5.6.2.</span> <span class="nav-text">Software Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NFU-Not-Frequently-Used-Algorithm"><span class="nav-number">5.6.2.1.</span> <span class="nav-text">NFU (Not Frequently Used) Algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Aging-Algorithm"><span class="nav-number">5.6.2.2.</span> <span class="nav-text">Aging Algorithm</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Working-Set-Page-Replacement-Algorithm"><span class="nav-number">5.7.</span> <span class="nav-text">The Working Set Page Replacement Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-WSClock-Page-Replacement-Algorithm"><span class="nav-number">5.8.</span> <span class="nav-text">The WSClock Page Replacement Algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DESIGN-ISSUES-FOR-PAGING-SYSTEMS"><span class="nav-number">6.</span> <span class="nav-text">DESIGN ISSUES FOR PAGING SYSTEMS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Local-versus-Global-Allocation-Policies"><span class="nav-number">6.1.</span> <span class="nav-text">Local versus Global Allocation Policies</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Size"><span class="nav-number">6.2.</span> <span class="nav-text">Page Size</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">6.3.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Implementation-Issues"><span class="nav-number">7.</span> <span class="nav-text">Implementation Issues</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Katherine</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Pilgrimss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Pilgrimss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yingeos@gmail.com" title="E-Mail → mailto:yingeos@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/kathyyw12" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;kathyyw12" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://drive.google.com/file/d/1FAOwzqj2iLnyNUCPUU_F-jXl5j2fN_0p/view?usp=sharing" title="About → https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;1FAOwzqj2iLnyNUCPUU_F-jXl5j2fN_0p&#x2F;view?usp&#x3D;sharing" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>About</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Katherine</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'gtbbAeJk0sTgEPBA9thJF4gU-gzGzoHsz',
      appKey     : '2HUdXVG1bF07KhQJCYIuKdom',
      placeholder: "Say what you want",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
